
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>PCIe Virtual Host</TITLE>
<META name="keywords" content="PCIe, IP, Intellectual Property, ASIC, FPGA, Semiconductors, Digital, Design, verification, test, HDL">
<META name="description" content="">

<STYLE type="text/css">
<!--
td {
        font-family: Tahoma, Arial, Helvetica, sans-serif;
        font-size: 11px;
}
tt {
        font-family: Consolas, mono, Courier New;
	font-size: 10.5pt;
        color:#1F497D
}
pre {
        font-family: Consolas, mono, Courier New;
        color:#1F497D
}
.content {
        padding-top: 20px;
        padding-right: 20px;
        padding-left: 20px;
        background-image: url(../wyvernsemi_files/e030_05.png);
        background-repeat: repeat-x;
        background-position: top;
    font-size:11pt;
}
.menuleft {
        height: 35px;
        padding-right: 15px;
        padding-left: 40px;
        vertical-align: middle;
        font-weight: bold;
        color: #000000;
        background-image: url(../wyvernsemi_files/e030_07.png);
        background-repeat: no-repeat;
        background-position: left;
}
a:link, a:visited {
        color: #FF0000;
        text-decoration: underline;
}
a:hover {
        color: #000099;
        text-decoration: none;
}
.menuleft a:link, .menuleft a:visited {
        color: #000000;
        text-decoration: none;
}
.menuleft a:hover {
        color: #000000;
        text-decoration: underline;
}
.footer, .footer a:link, .footer a:visited {
        color: #FFFFFF;
        padding-bottom: 25px;
}
.newsbar {
        color: #000000;
        font-weight: bold;
        padding-left: 40px;
}
.logo {
        font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
        font-weight: bold;
        color: #000000;
}
.leftcontent {
        padding-top: 10px;
        padding-right: 10px;
        padding-bottom: 25px;
        padding-left: 40px;
}
.style1 {font-size: 16px}
.date {
        color: #FFFFFF;
        padding-right: 15px;
        padding-left: 15px;
}
.logo1 {        font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
        font-weight: bold;
        color: #FFFFFF;
}
    p.MsoNormal, li.MsoNormal, div.MsoNormal
        {margin:0cm;
        margin-bottom:.0001pt;
        font-size:11.0pt;
        font-family:"Arial","sans-serif";}

-->
</STYLE>
<LINK href="../wyvernsemi_files/cms_style.css" rel="stylesheet" type="text/css">
<!--DHTML menu-->


 
</HEAD>
<!--- <BODY bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"> --->
<body vlink="#0000ff" alink="#0000ff" link="#0000ff" background="./images/wyvernbg.jpg"
leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">

<TABLE style="height: 100%;" border="0" cellspacing="0" cellpadding="0" width="100%" >
<TBODY>
<TR>
<TD height="100%" valign="top">

<TD class="content" valign="top">

<!--------------------------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------------------------->

<h1 align="center">PCIe Virtual Model Test Component</h1>
<hr>
<p>
<h2>Contents</h2>

<ul style="font-size:8pt;" >
<li><a href="#Summary">Summary</a>
<li><a href="#Verilog">Verilog</a>
<li><a href="#PciApi">PCIe API Code</a>
  <ul>
  <li><a href="#OpGen">User Output Generation</a>
  <li><a href="#IpProc">Input processing</a>
  <li><a href="#Training">Link Training</a>
  <li><a href="#AuxFunc">Auxiliary Functions</a>
  <li><a href="#IntMemAcc">Internal Memory Access</a>
  <li><a href="#Config">Model Initialisation and Configuration</a>
  <li><a href="#UsrProgStruct">Structure of a User Program</a>
  <li><a href="#ApiSumm">Summary of API Functions</a>
  </ul>
<li><a href="#IntArch">Further Internal Architecture</a>
  <ul>
  <li><a href="#IntFunc">Other Internal Functions</a>
  <li><a href="#IntMem">Internal Memory Structure</a>
    <ul>
    <li><a href="#cfgspc">Internal Endpoint Configuration Space</a>
    </ul>
  </ul>
<li><a href="#pciedisplink">PCIe Monitor (PcieDispLink)</a>
  <ul>
  <li><a href="#tl">Transaction Layer Only</a>
  <li><a href="#tldl">Transaction and Data Link Layer</a>
  <li><a href="#tldlpl">Transaction, Data Link and Physical Layer</a>
  <li><a href="#protocol">Protocol Checking</a>
  </ul>
<li><a href="#test">Test Environment</a>
<li><a href="#download">Download</a> 
<li><a href="#RelDoc">Related Documents</a>
</ul>

<a name="Summary"></a>
<h2>Summary</h2>

<p >
This model of a PCI Express host (with some endpoint features) is based on the Virtual 
Processor (<a href="https://github.com/wyvernSemi/vproc">VProc</a>) model (see 
<a href="http://www.anita-simulators.org.uk/wyvernsemi/VProc/index.html">VProc documentation</a>), 
with a PCIe API sitting atop the VProc's PLI API.

In summary, the model provides the following features:
</p>

<ul type=square>
 <li>All lane widths up to 16</li>
 <li>Internal memory space accessed with incoming write/read requests (can be disabled)</li>
 <li>Auto-generation of read completions (can be disabled)</li>
 <li>Auto-generation of 'unsupported' completions (can be disabled)</li>
 <li>Auto-generation of Acks/Naks (can be disabled)</li>
 <li>Auto-generation of Flow control (can be disabled)</li>
 <li>Auto-generation of Skip OS (can be disabled)</li>
 <li>User generation of all TLP types</li>
   <ul>
    <li>Memory Reads/Writes</li>
    <li>Read completions</li>
    <li>Config Reads/Writes</li>
    <li>IO Reads/Writes</li>
    <li>Messages</li>
   </ul>
 <li>User generation of all DLLP types</li>
   <ul>
    <li>Acks/Naks</li>
    <li>Flow control</li>
    <li>Power management</li>
    <li>Vendor</li>
   </ul>
 <li>User generation of all training sequences</li>
 <li>User generation of all ordered sets</li>
 <li>User generation of idle</li>
 <li>Proper throttling on received flow control</li>
 <li>Lane reversal</li>
 <li>Lane Inversion</li>
 <li>Serial input/output mode</li>
 <li>Programmable FC delay (via Rx packet consumption rates)</li>
 <li>Programmable Ack/Nak delay</li>
 <li>LTSSM (not yet implemented)</li>
 <li>MSI reception handling (not yet implemented)</li>
 <li>Programmable limit on completion size (splits) (not yet implemented)</li>
</ul>

<p>
The root directory for the PCIe model is <tt>pcieVHost/</tt>,
with C source in <tt>src/</tt> and the main verilog in the <tt>verilog/</tt> directory.
The package is available for download on <a href="https://github.com/wyvernSemi/pcievhost">github</a>.
The C source code files are:
</p>
<ul>
 <li><b>pci_express.h</b> : Generic PCI Express definitions</li>
 <li><b>pcie.h</b> : Main API header for inclusion in user code</li>
 <li><b>pcie.c</b> : API code</li>
 <li><b>pcie_utils.h</b> : Support function header</li>
 <li><b>pcie_utils.c</b> : Support function code</li>
 <li><b>codec.h</b> : Header for encode/decoder and scrambler code</li>
 <li><b>codec.c</b> : Encoder/decoder source</li>
 <li><b>mem.h</b> : Local memory header</li>
 <li><b>mem.c</b> : Local memory implementation</li>
 <li><b>pcicrc32.c</b> : CRC functions mapped as PLI verilog functions
 <li><b>veriuser.c</b> : PLI mapping functions and tables for pcieVHost and VProc
 <li><b>pcie_vhost_map.h</b> : definition of VProc register mappings for pciVHost
</ul>

<p>
The verilog files, under verilog/, are:
</p>

<ul>
  <li><b>pcieVHost/pcieVHost.v</b> : The main PCIe host module top level</li>
  <li><b>PcieDispLink/PcieDispLink.v</b> : top level PCIe monitor</li>
  <li><b>PcieDispLink/PcieDispLinkLane.v</b> : Individual lane display logic</li>
  <li><b>PcieDispLink/RxLaneDisp.v</b> : Receive decode structural verilog</li>
  <li><b>PcieDispLink/RxLogicDisp.v</b> : Lowest order receive decode logic</li>
  <li><b>lib/Crc16Gen.v</b> : CRC generation library for PCIe</li>
  <li><b>lib/Decoder.v</b> : 8/10b decode logic library</li>
  <li><b>lib/ScrambleCodec.v</b> : PCIe scramble logic library</li>
  <li><b>lib/Serialiser.v</b> : PCIe serialiser/deserialiser logic library</li>
  <li><b>lib/RxDp.v</b> : Receive data path library</li>
  <li><b>headers/pciexpress_header.v</b> : PCIe spec definitions</li>
  <li><b>headers/pciedispheader.v</b> : Definitions for PcieDisplLink</li>
  <li><b>headers/timescale.v</b> : Global time scale definitions</li>
  <li><b>headers/pcie_vhost_map.v</b> : Auto-generated pcieVHost register map for VProc programs</li>
</ul>

<p>
In addition to the pcieVHost and PcieDispLink files, an example <a href="#test">test environment</a>
is provided in the package, and these have files in the <tt>verilog/test/</tt> directory.
In here is the top level test file (<tt>test.v</tt>) and a display control component (<tt>ContDisps.v</tt>).
User code to run on the pcieVHosts is supplied as <tt>VUserMain0.c</tt> and <tt>VUserMain0.c</tt>, 
in the <tt>verilog/test/usercode/</tt> directory. a <tt>makefile</tt> is also provided in the test directory 
which builds everything needed to compile and run on ModelSim.
</p>

<a name="Verilog"></a>
<h2>Verilog</h2>
<p>
The verilog module simply maps 16, 10 bit registers, connected to the module 
output pins, into the VProc address space for writing, and the 16, 10 bit module 
inputs returning read data in the same address space (returned during both reads 
and writes). Additionally, three write only locations are provided for invoking 
<tt>$stop</tt>, <tt>$finish</tt> and <tt>`deaf</tt>. Two read locations give access to the modules node number 
and lane width parameter. An additional paramater can configure the pcieVHost as
an endpoint. What this actually means is that it has some memory is put aside
for a configurations space (unitialised) that can be written to over the link via a 
config write, and will generate completions to config reads, with the contents
of this memory.
</p><p>
This arrangement gives full control to the software for both outputing PCIe 10 bit
codes on the configured number of lanes, as well as access to raw 10 bit input data.
Although some amount of encoding and decoding could have been done in verilog (e.g.
10 bit codec, scrambling, physical layer framing etc.) this has been avoided to
give maximum control to the VProc software, enabling for greater flexibility and
visibility for generating and detecting exception cases. In order to ease 
construction of test software, however, an API is provided for the generation and 
processing of PCIe data. This, effectively, constitutes the model and is described 
in detail in later sections. 
</p><p>
The module definition for the model simply gives a clock and reset input, and the
16 lane input and output 10 bit wide links:
</p>

<pre style="font-size:8pt">
  module PcieVhost (Clk, notReset,
                    LinkIn0,   LinkIn1,   LinkIn2,   LinkIn3,
                    LinkIn4,   LinkIn5,   LinkIn6,   LinkIn7,
                    LinkIn8,   LinkIn9,   LinkIn10,  LinkIn11,
                    LinkIn12,  LinkIn13,  LinkIn14,  LinkIn15,
                    LinkOut0,  LinkOut1,  LinkOut2,  LinkOut3,
                    LinkOut4,  LinkOut5,  LinkOut6,  LinkOut7,
                    LinkOut8,  LinkOut9,  LinkOut10, LinkOut11,
                    LinkOut12, LinkOut13, LinkOut14, LinkOut15);
</pre>

<a name="PciApi"></a>
<h2>PCIe API Code</h2>

<p>
The PCIe API software constitutes a set of functions for generating any arbitrary
ordered sets, training sequences, data link layer packets or transaction layer
packets. Means are provided for constructing a set of packets for transmission
before presenting to the output to enable concatenation of packets at the 
lane level. The input is constantly sampled, and packets extracted and
passed to a central processing function. Also, the model has an internal
memory space which memory write and read requested get targeted at, and
any completion response required gets automatically generated. This can be 
disabled at initialisation so that memory reads and writes get passed to
user code. When disabled, it is up to the user code to generate the
appropriate completion, using the <tt>Completion()</tt> API function (see <a href="#PciApi">below</a>).
</p>

<center>
<div >
<img width=777 style="border:5px solid #d0e0e0; border-style:ridge;box-shadow: 10px 10px 10px #e0e0e0;" 
     src="images/PCIeModel.png"></a>
</div>
</center>
<br>
<p>
For user generated output data there are two classes of functions available:
Those that are queued (e.g. <tt>MemWrite()</tt> as shown in the top of the left most
boxes in the above diagram), and those that output immediately. All user generated
output calls go via a function <tt>SendPacket()</tt> except those functions in the
box that includes <tt>SendIdle()</tt>. The queued user calls all have the option
of adding to the queue and sending to the output, or of simply adding and
returning immediately to the user code for other additions to the queue.
The queue is of arbitrary length, and so, potentially, any sequence can be
built up as a contiguous set of packets before presenting to the output.
The <tt>SendPacket()</tt> and the three other direct user functions all call <tt>Encode()</tt>
in <tt>codec.c</tt> (as shown in the diagram as the right most box of the PCIe API), 
which performs the 8b/10b conversion and uses an internal function 
(<tt>ScrambleAdvance()</tt>) to scramble the data before issuing it to the PCIeVHost 
verilog via the VProc API.
</p><p>
At each clock the function <tt>ExtractPhyInput()</tt>
samples the lanes, and starts to build up packets as they arrive. When it 
has a whole packet, it calls <tt>ProcessInput()</tt>. What this does with the packet 
depends on the received packets type. If it is a memory request, it will access
the memory functions in <tt>mem.c</tt>. Memory writes are then completed. For reads
however, a read completion packet is constructed and added to the output
queue. Every received packet requires an acknowledgement. <tt>ProcessInput()</tt>
checks the CRC and flags to <tt>SendPacket()</tt> that either an Ack or Nak is
waiting. Since <tt>SendPacket()</tt> may be busy outputing another packet from the queue,
the Ack or Nak is delayed until the next packet boundary. <tt>ProcessInput()</tt>
also receives Acks and Naks for the packets that the model sent out, and
these are used to modify the code that controls the queue, such that
Naks cause the 'send pointer' to jump back to previously sent packets,
whilst Acks cause the head of the queue to move forward and the Acked
packets to be deleted from the queue. The only exception to this is
that DLLPs are also sent to the output via the queue (again this is so that
arbitrary sequences may be built up), but when the send point passes
over a DLLP it is removed from the queue immediately.
</p><p>
Two other important functions are provided to the user: <tt>InitialisePcie()</tt> and 
<tt>WaitForCompletion()</tt>. The first <em>must</em> be called before attempting
to use any other user outputing functions, and initialises the model. A pointer
to a callback function is passed to <tt>InitialisePcie()</tt> for passing up
received packets. The second function is a method for stalling the user 
code until a completion has arrived at the input. A completion does not 
have to be waited for immediately, and multiple requests can be issued 
before being a corresponding wait is called. 
</p><p>
Other functions are also available for adjusting the model, and are
described more fully below.
</p>

<a name="OpGen"></a>
<h3>User Output Generation</h3>
<p>
Most of the user output functions have a similar set of parameters.
(See <a href="#ApiSumm">Summary of API Functions</a> below). The
TLP generation functions all have an address, length (in bytes), tag,
requestor ID (<tt>rid</tt>), queue status and node number. The write functions
also have a pointer to the data. <tt>The Completion()</tt> functions also
requires a status and byte enables (for when a split completion is to be 
generated), as well as the completer's ID. For completions without
a payload, the address, byte enables and length are all set to 0, and
the data pointer set to <tt>NULL</tt>.  A sister function to Completion exists
called <tt>PartCompletion()</tt>. This is almost identical, but has an addition
<tt>rlength</tt> argument (remaining length) used to calculate the header
byte count, which may include additional bytes not present in the 
completion, for generation of multiple completions. Valid staus
value for the completion functions are:
</p>

<ul>
 <li><tt>CPL_SUCCESS</tt>
 <li><tt>CPL_UNSUPPORTED</tt>
 <li><tt>CPL_CRS</tt>
 <li><tt>CPL_ABORT</tt>
</ul>

<p>
Both the completion digest functions have a 'delay' equivalent, with a boolean
delay argument for the part-completion function, added to control whether the completion 
is added to the normal queue, or whether it is added to a special delayed queue. 
The <tt>CompletionDelay()</tt> function always has the delay, queue and digest flags active.
The delay is controlled by user configuration, via <tt>CONFIG_CPL_DELAY_RATE</tt> and 
<tt>CONFIG_CPL_DELAY_SPREAD</tt> (see <a href="#Config">Model Initialisation and Configuration</a>).
</p>
<p>
All the output functions have a 'digest' equivalent. These are basically
the same functions, but with an extra 'digest' parameter to control
whether the resulting generated packets have a digest (ECRC) word.
The output functions also return a pointer to the packet data
generated by the function. This pointer is only valid if the functions
are called with the 'queue' parameter set to <tt>QUEUE</tt>. If set to <tt>SEND</tt>
then <tt>NULL</tt> is return, since it cannot be guaranteed that the allocated
memory containing the packet has not been freed. With a valid pointer
returned, the user code has an opportunity to modify the packet
(e.g. to deliberately corrupt it) before calling <tt>SendPacket()</tt>
to flush the packet onto the link.
</p><p>
The <tt>SendMessage()</tt>
function replaces the address with the message code, and the DLLP 
functions have less parameters, and are specific to the DLLP type.
</p><p>
As mentioned previously, the output functions available to the user
code are divided into two categories; queued and non-queued. In addition
(hidden from the user code), the functions are also divided by another
category, namely template generated or non-template generated. All the
queued functions are also templated, but additionally <tt>SendAck()</tt> and
<tt>SendNak()</tt> also use templates.
</p>
<h4>Templates</h4>
<p>
Within <tt>pcie_utils.c</tt> are two local functions for generating templates for output 
packets; <tt>CreateTlpTemplate()</tt> and <tt>CreateDllpTemplate()</tt>. A set of
parameters are passed into to configure the header, and the function
allocates some memory, adequate for the size of the packet, and
fills in some default values, as well as the specified parameters. They
return a pointer to allocated space, and also, for convenience, a pointer 
to the start of the data portion of the packet (the byte after the header).
</p>

<h4>Output Function Structure</h4>
<p>
Each of the user output functions call the appropriate <tt>CreateTemplate</tt>
function and modifies the defaults if required, and calculates the
CRC(s). The pointer for this completed packet is then added to
an entry of a structure which the function has created, again by
requesting some space in memory. This 'packet type' structure (<tt>Pkt_t</tt>)
then consists of the pointer for the packet data, an assigned sequence
number, and a, as yet, unassigned 'next point' used for constructing
the linked list output queue. A <tt>TimeStamp</tt> field is also defined, which
is used only on incoming packets (see <a href="#IpPktProc">below</a>). 
The <tt>Pkt_t</tt> structure is shown below:
</p>

<pre style="font-size:8pt">
    typedef struct pkt_struct *pPkt_t;
    typedef struct pkt_struct {
        pPkt_t    NextPkt;     // pointer to next packet to be sent
        PktData_t *data;       // pointer to a raw data packet, terminated by -1
        int       seq;         // DLL sequence number for packet (-1 for DLLP)
        uint32    TimeStamp;
    } sPkt_t;
</pre>

<p>
The packet is now ready for adding to
the queue, and the output function calls <tt>AddPktToQueue()</tt>, to place
it on the output queue. When the user called the output function,
a flag <tt>queue</tt> was passed in. If set, the function returns after
the packet has been added. If not set, then the newly added packet,
along with any previously unsent packets on the queue, are sent
to the output by calling <tt>SendPacket()</tt>. This basic operational structure
is common to all the output functions except <tt>SendAck()</tt> and <tt>SendNak()</tt>.
</p><p>
Sending of Acks and Naks are not queued because it is not always
desirable to send an Ack/Nak for every single packet sequence. The
PCI Express specification allows Acks to accumulate such that
and Ack of a given sequence number implies an Ack for that sequence
number <em>and</em> all as yet unacknowledged packets. Since
the transmission of Acks can be held up if <tt>SendPacket()</tt> is busy,
the <tt>SendAck()</tt> and <tt>SendNak()</tt> functions keep track of what
Ack is pending to send, and <tt>SendPacket()</tt> samples this in between
the sending of packets (or when idle) and sends whatever
acknowledge is indicated in the cycle. The functions still
create a template for the Ack, but if an ack is superseded,
the old packet is discarded within the Send functions and 
a new one created. The <tt>SendAck()</tt> and <tt>SendNak()</tt> functions are usually
only called by the <tt>ProcessInput()</tt> function, but they may also
be called from the user code if, for instance, an acknowledge
error condition is required, or the user has disabled auto-ack
generation. However, calling <tt>SendAck()</tt> or <tt>SendNak()</tt> does not
guarantee that an acknowledge is sent immediately, but only
updates the internal state of pending ACK/NAK sequence.
</p>

<h4>Output Queue</h4>
<p>
The output queue is a linked list of 'packet types' (<tt>Pkt_t</tt>) which
is managed via three pointers: <tt>head_p</tt>, <tt>send_p</tt> and <tt>end_p</tt>. As one
would expect, <tt>head_p</tt> always points to the first unacknowledged
packet. The <tt>send_p</tt> pointer always points to the next packet
to output, and <tt>end_p</tt> points to the last packet in the queue. When
<tt>AddPktToQueue()</tt> is called the packet pointed to by <tt>end_p</tt> has its
<tt>NextPtr</tt> field (which would be <tt>NULL</tt>) set to point to the new packet,
and <tt>end_p</tt> is updated to also point to the new packet. When
<tt>SendPacket()</tt> is called each packet is output, with <tt>send_p</tt>
traversing the linked list from its starting point until
it hits the <tt>NULL</tt> <tt>NextPtr</tt> of the end packet. The <tt>send_p</tt> pointer
can be modified, however, if a packet receives a Nak. In this
case <tt>send_p</tt> is set to the head of the queue, and traverses the
list until it points to the packet with the same sequence as the Nak.
The <tt>head_p</tt> pointer remains fixed until a successful acknowledge
is received. The head_p pointer the traverses the list to one
beyond the ack sequence (which could be <tt>NULL</tt> if all packets acknowledged).
</p><p>
One deviation from the above procedure occurs. Most DLLPs are also
placed on the queue, but aren't acknowledged and mustn't be resent.
When the <tt>send_p</tt> passes over a DLLP it must be removed from the queue.
The DLLP may be at the head of the queue, in which case <tt>head_p</tt> must
move forward one, at the end of the queue, in which case <tt>end_p</tt> must
move back one, or in the middle, in which case the <tt>NextPtr</tt> of the 
previous packet must be set to point to the packet after the DLLP.
</p><p>
In all cases of a packet being removed from the queue, either an
acknowledged TLP or a sent DLLP, at that point the memory allocated
for the packet is freed so as to prevent a memory leak.
</p>

<h4>Non-packet Output</h4>
<p>
The three functions <tt>SendIdle()</tt>, <tt>SendOS()</tt> and <tt>SendTS()</tt> are used to
send output that is not within a packet, and is, indeed, sent
linearly within the lanes, rather than striped across them. In order
for input to be processed correctly, and to correctly comply with
output requirements, something must be sent at all times, allowing
<tt>SendPacket()</tt> to fetch the input state and send it to <tt>ExtractPhyInput()</tt>. 
The <tt>SendIdle()</tt> function is used to do this, and can be called with
a 'tick' count to indicate for how long it is required to be idle. Also,
if <tt>WaitForCompletion()</tt> has been called this implicitly calls <tt>SendIdle()</tt>
whilst it is waiting on the completion event. Ordered sets and training
sequences can only be sent in between packets, but so long as a <tt>SendPacket()</tt>
has been issued before calling them (i.e. <tt>queue</tt> is false on the last
call to an output function) then this will be safe.
</p>

<a name="IpProc"></a>
<h3>Input processing</h3>

<h4>Extracting Data From The Input Link</h4>
<p>
The input links are constantly sampled, each and every time something
is output. Since there is always something output (even if just Idle
bytes), the input is sampled every symbol time. As can be seen from
the diagram, output only comes directly from two sources&mdash;either
<tt>SendPacket()</tt>, or the group of low level output functions (<tt>SendIdle()</tt>,
<tt>SendTS()</tt> and <tt>SendOS()</tt>). All these functions extract the returned 
10 bit word from the input lane as it writes to the corresponding output 
lane, and places it into an array (<tt>LinkIn</tt>). At the end of the sweep
across the lanes, <tt>ExtractPhyInput()</tt> is called, passing in the input
array with the new input codewords.
</p><p>
<tt>ExtractPhyInput()</tt> decodes the 10bit words, and monitors for new TLP
or DLLP packets. When an <tt>STP</tt> or <tt>SDP</tt> is seen, some memory space is
allocated for a maximum size packet. This spaced is filled with the
incoming data until and termination symbol (<tt>END</tt> or <tt>EDB</tt>) is 
encountered. At this point, 
the memory is reallocated to reduce to the actual size of the packet. 
A new packet type structure is created, with a filled in sequence number 
extracted from the header, and the entire packet is passed to <tt>ProcessInput()</tt>.
</p>
<a name="IpPktProc"></a>
<h4>Input Packet Processing</h4>
<p>
All packets are processed through <tt>ProcessInput()</tt>. If the packet is a DLLP,
it is CRC checked, then its type is tested and processed internally to 
<tt>ProcessInput()</tt> if its an Ack or flow control type. Automatic processing 
of acknowledges can be disabled via <tt>ConfigurePcie()</tt>, in which case the 
DLLP is sent to the user registered function (if any). For internally 
handled acknowledges the <tt>curr_ack</tt> or <tt>curr_nak</tt> sequence numbers are updated, 
and at the next call to <tt>SendPacket()</tt> any acknowledged packets are deleted 
from the head of the queue, or NAK'ed packets resent by updating the send 
pointer to include the lowest sequence NAK'ed packet. When acking is disabled, 
packets are deleted from the queue immediately they are sent and it is the 
responsibility of the user to resend packets that have been NAK'ed.
</p><p>
For the flow control DLLPs the appropriate
<tt>FlowCntlDataCredits</tt> and <tt>FlowCntlHdrCredits</tt> counts are updated, which are
used to stall the sending of packets when appropriate. Like acknowledges,
flow control may be disabled via <tt>ConfigurePcie()</tt>, in which case all
flow control DLLPs are sent to the user registered function, and the
user code must manage throttling of packets. All other DLLPs are not 
supported and generate a warning upon receipt.
</p><p>
Transaction layer packets are first checked for good CRC(s), and then
handled depending on the type. Memory read or write requests access
the internal memory (via functions in <tt>mem.c</tt>) when memory is enabled, whilst 
completions increment a completion count (used by <tt>WaitForCompletion()</tt>&mdash;see 
below) and, if a user function has been registered, is passed to the user
code for further processing. Also, packets with failing CRCs, are also passed 
to the user function, for stats gathering, scoreboarding etc., though the user 
function may also choose to do nothing with them. All other TLP types are 
unsupported (presently) and generate a warning message, and get passed up
to the user function (if registered). The user function, when finished
processing returned packets, must free the memory of the packet to prevent
a memory leak. A macro is provided to do this function&mdash;<tt>DISCARD_PACKET(_PKT)</tt>.
The packets passed to the user registered input function
will have the TimeStamp field of the <tt>Pkt_t</tt> structure filled in with the
clock cycle it was processed. This is useful if user code wishes to implement
delaying of responses to these packets by comparing the <tt>TimeStamp</tt> with
the current cycle time (accessed using <tt>GetCycleCount()</tt>). If, when internal 
memory is enabled, a memory read request is processed, <tt>ProcessInput()</tt> generates 
a read completion packet, which is added to the output queue for transmission. 
It calls the user API function <tt>Completion()</tt> to do this. If memory is disabled, 
it is up to the user code to generate any completions.
</p><p>
All the TLP packets generate an acknowledge after the CRC has been
checked, with <tt>ProcessInput()</tt> calling either the user API functions <tt>SendAck()</tt>
or <tt>SendNak()</tt> as appropriate. Automatic acknowledging can be disabled, however,
via <tt>ConfigurePcie()</tt>, in which case the user code must generate the 
acknowledges as appropriate.
</p><p>
All packets passed to the user callback function are 'whole', in that they
contain a flat data structure containing unprocessed physical layer packets 
(though 8b/10b decoded). In order to extract useful information from the packet
as series of macros are provided in <tt>pcie.h</tt>, which take a packet pointer and
'return' a value. Below are shown the currently supplied macros for TLP packets.
</p>
<pre style="font-size:8pt">
    // Extract header fields
    GET_TLP_TYPE(_PKT)
    GET_TLP_LENGTH(_PKT)
    GET_TLP_FBE(_PKT)
    GET_TLP_LBE(_PKT)
    GET_TLP_TAG(_PKT)           // Not Completions
    GET_TLP_RID(_PKT)           // Not completions
    GET_CPL_TAG(_PKT)           // Completions only
    GET_CPL_BYTECOUNT(_PKT)     // Completions only
    GET_CPL_CID(_PKT)           // Completions only
    GET_CPL_STATUS(_PKT)        // Completions only
    GET_TLP_ADDRESS(_PKT)       // Get address as 64 bit number (even if 3DW header)
    GET_TLP_PAYLOAD_PTR(_PKT)   // Return a pointer to the start of the payload

    // Return status
    TLP_HAS_DIGEST(_PKT)        // True if an ECRC present (TD bit set)
    TLP_HDR_4DW(_PKT)           // True if a 4DW header type
    TLP_IS_POSTED(_PKT)         // True if packet is a posted request
</pre>

<p>
Bad, as well as good, packets are passed to the user registered callback function,
and their status is passed in as the second argument. The value is a bit field
indicating different error status types in each bit. The currently supported status bits, 
as defined in <tt>pcie.h</tt>, are as follows:
</p>
<ul>
 <li><tt>PKT_STATUS_BAD_LCRC</tt>
 <li><tt>PKT_STATUS_BAD_ECRC</tt>
 <li><tt>PKT_STATUS_UNSUPPORTED</tt>
 <li><tt>PKT_STATUS_NULLIFIED</tt>
</ul>

<a name="Training"></a>
<h3>Link Training</h3>
<p>
A couple of high level functions are provided in the pcieVHost API, which can be used
to do initial link training and flow control initialisation. These are not meant to be full
implementations, covering all exceptions and eventualities, but can be used to go from a cold start,
power up to L0 state, and set initial flow control values for P, NP and Cpl packets. The
example <a href="#test">test environment</a> instantiates two pcieVHost modules back-to-back,
and calls these API functions from the two test programs to do just this.
</p>
<p>
To go from a 'Detect' state to 'L0' state, the users program must call <tt>InitLink()</tt>. In
addition to the <tt>node</tt> argument (common to all API functions) a <tt>linkwidth</tt> argument is
required. This is not left to a default value, as it is essential that the training sequence
matches the actual linkwidth that exists on the pcieVHost that the program making the call
is running from. Other parameters can be set separately with <tt>ConfigurePcie()</tt>
(see <a href="#Config">Model Initialisation and Configuration</a> section),
which can be left to default values if required, or configured to different settings. 
<tt>CONFIG_LTSSM_LINKNUM</tt> defaults to 0, which
is a likely scenario, but this can be updated to be between 0 and 255. The number of fast training sequences
set with <tt>CONFIG_LTSSM_N_FTS</tt>, defaults to 255, and has the same range as the link number. The five
bit training sequence control field, for hot resets, loopbacks scrambling control etc., can be set 
via <tt>CONFIG_LTSSM_TS_CTL</tt>. The LTSSM function has abbreviated sequences, due to the time required for
some steps (e.g. 24ms). The detect state timeout can be updated with <tt>CONFIG_LTSSM_DETECT_QUIET_TO</tt>. Its
units are in clock cycles.
</p>
<p>
The <tt>CONFIG_LTSSM_ENABLE_TESTS</tt> and <tt>CONFIG_LTSSM_FORCE_TESTS</tt> configuration types
control certain useful test behaviours of the LTSSM. The difference between the enable and force 
configurations is that the enable will only do the behaviour on average once in every three iterations, 
whereas a force enables the feature constantly, and thus overrides any equivalent enable setting. 
The configuration settings are a bit mask, with supported values as listed below:
</p>

<ul>
  <li><tt>ENABLE_DISABLE</tt>
  <li><tt>ENABLE_COMPLIANCE</tt>
  <li><tt>ENABLE_LOOPBACK</tt>
</ul>

<p>
The <tt>ENABLE_DISABLE</tt> setting enables/forces going to the 'Disabled' state from 
configuration start. The <tt>ENABLE_COMPLIANCE</tt> bit forces/enables going to
polling compliance when entering polling state, instead of polling active. Finally,
<tt>ENABLE_LOOPBACK</tt> force/enables going to 'Loopback' state from configurations
start. Use of these controls is at the discretion of the user, as setting them interrupts
the transition from 'Detect' to 'L0' states.
</p>
<p>
Once a link has been trained, and reached state L0, the initialisation of flow control values
over the link can be set with a call to <tt>InitFc()</tt>. The values advertised are configured
via <tt>ConfigurePcie()</tt>, with relevant types <tt>CONFIG_&lt;type&gt;_HDR_CR</tt> and 
<tt>CONFIG_&lt;type&gt;_DATA_CR</tt>, with <tt>&lt;type&gt;</tt> being one of <tt>POST</tt>,
<tt>NONPOST</tt> or <tt>CPL</tt>.
</p>

<a name="AuxFunc"></a>
<h3>Auxiliary Functions</h3>
<p>
<tt>WaitForCompletion()</tt>, which simply has a <tt>node</tt> input argument, is used for stalling 
the user code until such time as a completion has been seen. It effectively tests a 
count (<tt>CompletionEvent</tt>) which, if zero, will stall in the function, sending out idles, 
until the count is non-zero. The count is then decremented by the function. With this 
arrangement, multiple packets (with completions) can be output before waiting on a 
return. If, at a later time, a wait is called and type count is already non-zero, 
the <tt>WaitForCompletion()</tt> simply drops through, decrementing as it goes. To wait for 
multiple completions to occur at the same point in the user code, <tt>WaitForCompletionN()</tt>
is called with the required number completion events as its first argument.
</p><p>
It should be noted that the <tt>WaitForCompletion()</tt> function is stalling on
a whole completion. That is to say, if the completer returns completion data
as multiple completions for the same tag, only the final completion increments
the event count. It is up to the user registered input function to process
multiple completions, and keep track of earlier partial comepletion, ready for
use by the <tt>VUserMain</tt> flow.
</p>

<a name="IntMemAcc"></a>
<h3>Internal Memory Access</h3>
<p>
The PCIe model's internal memory may be accessed from user code (<tt>VUserMain<i>N</i>()</tt>
etc.) To write to the memory <tt>WriteRamByteBlock()</tt> is used. This takes a 32 bit aligned
address, a pointer to a <tt>PktData_t</tt> buffer containing bytes, a first and last
byte enable (4 bits each) and a byte length which is a multiple of 4 bytes. If it's
required to write data not aligned to 32 bits, then the byte enables are used, but
the data buffer will start at the 32 bit aligned address and must be padded in
the disabled byte positions. To read back data, a similar call (<tt>ReadRamByteBlock()</tt>)
is made, with the same arguments as <tt>WriteRamByteBlock()</tt>, but without the
byte enables. <tt>ReadRamByteBlock()</tt> returns 0 on successfully reading from memory,
but returns non-zero if there was an error, such as reading an uninitialised 
block. In the error case no data is returned, and the buffer remains unchanged.
Some simpler functions are provided for individual byte and word
reads and write (see <a href="#ApiSumm">Summary of API Functions</a> for a list
of these functions). These return a data value of 0 for accesses to 
uninitialised memory blocks.
</p>

<a name="Config"></a>
<h3>Model Initialisation and Configuration</h3>
<p>
A single function provides all the initialistion required by the model.
<tt>InitilisePcie()</tt> <em>must</em> be called from the user code before any other API 
function call is made. It has only two arguments, the first of which allows 
registration of a user function to be called whenever a completion type packet 
is received at the input (e.g. read completion, configuration write completion, 
etc.). The user function is responsible for handling these packets, though they 
will have been CRC checked and are always delivered valid. This argument may be 
<tt>NULL</tt> if it is not required to process these packets. The second argument is the
VProc node number of the program.
</p><p>
The model works 'out of the box' as it were, but may be configured, either
immediately after initialisation or at future points during simulation. Only
one function is used to provide all configuration access; <tt>ConfigurePcie()</tt>.
Its first argument is a 'type' selecting which parameter is to be altered
and the second is an integer value. Some types do not require value, in
which case the value argument is a 'don't care' (so usually set to 0 or <tt>NULL</tt>).
A list of valid types, and whether requiring a value, is given below.
</p>
<table style="font-size:10pt; color:#000000" align=center cellspacing=0 cellpadding=4 border=1>
 <tr><th>TYPE</th><th>VALUE?</th><th>UNITS</th><th>Description</th></tr>
 <tr><td><tt>CONFIG_FC_HDR_RATE</tt></td>             <td align=center>yes</td> <td>cycles</td>  <td>Rx Header consumption rate (default 4)</td></tr>
 <tr><td><tt>CONFIG_FC_DATA_RATE</tt></td>            <td align=center>yes</td> <td>cycles</td>  <td>Rx Data consumption rate (default 4)</td></tr>
 <tr><td><tt>CONFIG_ENABLE_FC</tt></td>               <td align=center>no</td>  <td>&nbsp;</td>  <td>Enable auto flow control (default)</tr>
 <tr><td><tt>CONFIG_DISABLE_FC</tt></td>              <td align=center>no</td>  <td>&nbsp;</td>  <td>Disable auto flow control</td></tr>
 <tr><td><tt>CONFIG_ENABLE_ACK</tt></td>              <td align=center>yes</td> <td>cycles</td>  <td>Enable auto acknowledges with processing rate (default rate 1)</td></tr>
 <tr><td><tt>CONFIG_DISABLE_ACK</tt></td>             <td align=center>no</td>  <td>&nbsp;</td>  <td>Disable auto acknowledges</td></tr>
 <tr><td><tt>CONFIG_ENABLE_MEM</tt></td>              <td align=center>no</td>  <td>&nbsp;</td>  <td>Enable internal memory (default)</td></tr>
 <tr><td><tt>CONFIG_DISABLE_MEM</tt></td>             <td align=center>no</td>  <td>&nbsp;</td>  <td>Disable internal memory</td></tr>
 <tr><td><tt>CONFIG_ENABLE_SKIPS</tt></td>            <td align=center>yes</td> <td>cycles</td>  <td>Enable regular Skip ordered sets, with interval (default interval 1180)</td></tr>
 <tr><td><tt>CONFIG_DISABLE_SKIPS</tt></td>           <td align=center>no</td>  <td>&nbsp;</td>  <td>Disable regular Skip ordered sets</td></tr>
 <tr><td><tt>CONFIG_ENABLE_UR_CPL</tt></td>           <td align=center>no</td>  <td>&nbsp;</td>  <td>Enable auto unsupported request completions (default)</td></tr>
 <tr><td><tt>CONFIG_DISABLE_UR_CPL</tt></td>          <td align=center>no</td>  <td>&nbsp;</td>  <td>Disable auto unsupported request completions</td></tr>
 <tr><td><tt>CONFIG_POST_HDR_CR</tt>&dagger;</td>     <td align=center>yes</td> <td>credits</td> <td>Initial advertised posted header credits (default 32)</td></tr>
 <tr><td><tt>CONFIG_POST_DATA_CR</tt>&dagger;</td>    <td align=center>yes</td> <td>credits</td> <td>Initial advertised posted data credits (default 1K)</td></tr>
 <tr><td><tt>CONFIG_NONPOST_HDR_CR</tt>&dagger;</td>  <td align=center>yes</td> <td>credits</td> <td>Initial advertised non-posted header credits (default 32)</td></tr>
 <tr><td><tt>CONFIG_NONPOST_DATA_CR</tt>&dagger;</td> <td align=center>yes</td> <td>credits</td> <td>Initial advertised non-posted data credits (default 1)</td></tr>
 <tr><td><tt>CONFIG_CPL_HDR_CR</tt>&dagger;</td>      <td align=center>yes</td> <td>credits</td> <td>Initial advertised completion header credits (default &infin;)</td></tr>
 <tr><td><tt>CONFIG_CPL_DATA_CR</tt>&dagger;</td>     <td align=center>yes</td> <td>credits</td> <td>Initial advertised non-posted data credits (default &infin;)</td></tr>
 <tr><td><tt>CONFIG_CPL_DELAY_RATE</tt>&dagger;</td>  <td align=center>yes</td> <td>cycles</td><td>Auto completion delay rate (default 0)</td></tr>
 <tr><td><tt>CONFIG_CPL_DELAY_SPREAD</tt>&dagger;</td><td align=center>yes</td> <td>cycles</td><td>Auto completion delay randomised spread (default 0)</td></tr>
 <tr><td><tt>CONFIG_LTSSM_LINKNUM</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>integer</td><td>Training sequence advertised link number (default 0)</td></tr>
 <tr><td><tt>CONFIG_LTSSM_N_FTS</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>integer</td><td>Training sequence number of fast training seqences (default 255)</td></tr>
 <tr><td><tt>CONFIG_LTSSM_TS_CTL</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>integer</td><td>Five bit TS control field (default 0)</td></tr>
 <tr><td><tt>CONFIG_LTSSM_DETECT_QUIET_TO</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>cyles</td><td> Detect quite timeout</td></tr>
 <tr><td><tt>CONFIG_LTSSM_ENABLE_TESTS</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>bit mask</td><td>Enable LTSSM test exceptions (default 0)</td></tr>
 <tr><td><tt>CONFIG_LTSSM_FORCE_TESTS</tt>&dagger;&dagger;</td><td align=center>yes</td> <td>bit mask</td><td>Force LTSSM test exceptions (default 0)</td></tr>
 <tr><td colspan=4>&dagger; Call immediately after <tt style="font-size:8pt;">InitialisePcie()</tt> to take effect from time 0<br>
                   &dagger;&dagger; Call before calling <tt style="font-size:8pt;">InitLink()</tt> to take effect in training sequences. 
		                    (see  <a href="#Training">Link Training</a> section.)</td></tr>
</table>

<a name="UsrProgStruct"></a>
<h3>Structure of a User Program</h3>
<p>
There are many ways that a user program could be constructed to utilise the
PCIe model, but there are some common components that would feature in
any implementation, which are discussed now. Below is shown an example
outline of a basic VUserMain program for the model:
</p>

<pre style="font-size:8pt; color:#000040">
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include "pcie.h"
    
    #define RST_DEASSERT_INT 4
    
    static int node               = 0;
    static unsigned int Interrupt = 0;
    
    static int ResetDeasserted(void)
    {
        Interrupt |= RST_DEASSERT_INT;
    }
    
    static void VUserInput(pPkt_t pkt, int status, void* usrptr) 
    {
        /* ---- User processing of received packets here ---- */ 

        DISCARD_PACKET(pkt);
    }
    
    void VUserMain0() 
    {
        VRegInterrupt(RST_DEASSERT_INT, ResetDeasserted, node);
        InitialisePcie(VUserInput, node);
    
        do
        {
            SendOs(IDL, node);
        }
        while (!Interrupt);

        Interrupt &= ~RST_DEASSERT_INT;

	InitLink(16, node);
        InitFc(node);

        /* ---- User calls to packet generation functions here ---- */
    
        SendIdle(100, node);
        
        VWrite(PVH_FINISH, 0, 0, node);
    }
</pre>

<p>
The above code assumes that the PCIe model is configured at node 0. The call
to <tt>VRegInterrupt()</tt> connects the callback function <tt>ResetDeasserted()</tt> to the
reset interrupt so that we can wait until after reset is removed, whilst the <tt>InitialisePcie()</tt>
sets up the model for this node and registers <tt>VUserInput()</tt> as the callback for
unhandled packets. With no link training startup code, the program simply
outputs <tt>IDL</tt> ordered sets (<tt>SendOs()</tt>) until reset is deasserted.
A link initialisation is instifated with a call to <tt>InitLink()</tt>, followed by
Flow control initialisation with <tt>InitFc()</tt>, and then the model is ready to go. 
If either link initialiasation or configuration needs non-conformant sequences, or
different values for testing, etc., the the calls to these functions can be skipped,
and replaced with user code to output different patterns as required.
</p><p>
At this point other user functions may be called to implement behaviour, or 
the user code simply inserted directly into <tt>VUserMain()</tt>. At its simplest, 
the user code would normally be calls to <tt>MemRead()</tt>, <tt>MemWrite()</tt> and <tt>Completion()</tt>
(or possibly <tt>PartCompletion()</tt> if the completion must be split). Also <tt>CfgRead()</tt>
and <tt>CfgWrite()</tt> if config space accesses are required. The <tt>WaitForCompletion()</tt>
function would be used for synchronising of returned data to non-posted requests. 
Some of the details of the API calls could be tidied away in user data hiding 
modules, so that requestor ID, node number etc. are not visible to the user's 
main program code. With the model configured to its default, the <tt>VUserInput()</tt>
should only ever be called with corrupted packets. To receive all transaction 
layer packets <tt>ConfigurePcie()</tt> is called just after <tt>InitialisePcie()</tt> with 
<tt>CONFIG_DISABLE_MEM</tt> to pass up memory reads and writes, and with <tt>CONFIG_DISABLE_UR_CPL</tt>
to receive unsupported packet types. All data link layer packets are handled 
automatically by default, so <tt>CONFIG_DISABLE_FC</tt> and <tt>CONFIG_DISABLE_ACK</tt> can be used 
to receive these. In this way the user code can choose what level of handling 
it wishes to implement, be it its own memory model, error reporting or link 
protocol handling.
</p><p>
The user code may be an infinite loop, if required, but if it ever returns it
is possible to terminate, stop or <tt>`deaf</tt> the simulation from within <tt>VUserMain()</tt>
using a low level VProc call. In the example, idles are sent for a short time to flush
the link, especially for PcieDispLinks, and then a VProc write (<tt>VWrite()</tt>) to
an address '<tt>PVH_FINISH</tt>' terminates the simulation. Two other addresses (<tt>PVH_STOP</tt> and
<tt>PVH_DEAF</tt>) perform the equivalent functions.
</p><p>
As has been mentioned elsewhere, <tt>VUserMain()</tt> and the callback function (<tt>VUserInput()</tt>)
are not running in separate threads, and so it is safe to share memory between them. 
If a user program instigates new threads, however, care must be to avoid race 
conditions and contentions between transmitter and receiver code, and the model's
API thread. E.g. it is hazardous to call API code from a separate thread to <tt>VUserMain()</tt>, 
and proper resynchronisation should be employed.
</p>

<a name="ApiSumm"></a>
<h3>Summary of API Functions</h3>

<h4>TLP Output Functions</h4>
<pre style="font-size:8pt">
    pPktData_t MemWrite             (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, bool queue, int node);
    pPktData_t MemRead              (uint64 addr, int length, int tag, uint32 rid, bool queue, int node);
    pPktData_t Completion           (uint64 addr, PktData_t *data, int status, int fbe, int lbe, 
                                     int word_length, int tag, uint32 cid, uint32 rid, bool queue, int node);
    pPktData_t PartCompletion       (uint64 addr, const PktData_t *data, int status, int fbe, int lbe, int word_rlength, int word_length, 
                                     int tag, uint32 cid, uint32 rid, bool queue, int node);
    pPktData_t CfgWrite             (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, int queue, int node);
    pPktData_t CfgRead              (uint64 addr, int length, int tag, uint32 rid, bool queue, int node);
    pPktData_t IoWrite              (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, bool queue, int node);
    pPktData_t IoRead               (uint64 addr, int length, int tag, uint32 rid, bool queue, int node);
    pPktData_t Message              (int code, PktData_t *data, int length, int tag, uint32 rid, bool queue, int node);

    pPktData_t MemWriteDigest       (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, bool digest, bool queue, int node);
    pPktData_t MemReadDigest        (uint64 addr, int length, int tag, uint32 rid, bool digest, bool queue, int node);
    pPktData_t CompletionDigest     (uint64 addr, PktData_t *data, int status, int fbe, int lbe, 
                                     int word_length, int tag, uint32 cid, uint32 rid, bool digest, bool queue, int node);
    pPktData_t PartCompletionDigest (uint64 addr, const PktData_t *data, int status, int fbe, int lbe, int word_rlength, int word_length, 
                                     int tag, uint32 cid, uint32 rid, bool digest, bool queue, int node);
    pPktData_t CfgWriteDigest       (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, bool digest, bool queue, int node);
    pPktData_t CfgReadDigest        (uint64 addr, int length, int tag, uint32 rid, int digest, int queue, int node);
    pPktData_t IoWriteDigest        (uint64 addr, PktData_t *data, int length, int tag, uint32 rid, bool digest, bool queue, int node);
    pPktData_t IoReadDigest         (uint64 addr, int length, int tag, uint32 rid, bool digest, bool queue, int node);
    pPktData_t MessageDigest        (int code, PktData_t *data, int length, int tag, uint32 rid, bool digest, bool queue, int node);

    pPktData_t CompletionDelay      (uint64 addr, PktData_t *data, int status, int fbe, int lbe, int length, int tag, 
                                     uint32 cid, uint32 rid, int node);
    pPktData_t PartCompletionDelay  (uint64 addr, PktData_t *data, int status, int fbe, int lbe, int rlength, int length, int tag, 
                                     uint32 cid, uint32 rid, bool digest, bool delay, bool queue, int node);

    void       SendPacket           (void);
</pre>

<h4>DLLP Output Functions</h4>
<pre style="font-size:8pt">
    void SendAck    (int seq, int node);
    void SendNak    (int seq, int node);
    void SendFC     (int type, int vc, int hdrfc, int datafc, bool queue, int node);
    void SendPM     (int type, bool queue, int node);
    void SendVendor (bool queue, int node);
</pre>

<h4>Low Level Output</h4>
<pre style="font-size:8pt">
    void SendIdle (int Ticks, int node);
    void SendOs   (int Type, int node);
    void SendTs   (int identifier, int lane_num, int link_num, int n_fts, int control, bool is_gen2, int node);
</pre>

<h4>Low Level Input</h4>
<pre style="font-size:8pt">
    int  ResetEventCount (int type, int node);
    int  ReadEventCount  (int type, uint32 *ts_data, int node);
    TS_t GetTS           (int lane, int node);
</pre>

<h4>Link Training</h4>
<pre style="font-size:8pt">
    void InitLink       (int linkwidth, int node);
    void InitFc         (int node);
</pre>

<h4>Miscellaneous Functions</h4>
<pre style="font-size:8pt">
    void   WaitForCompletion  (int node);
    void   WaitForCompletionN (unsigned int count, int node);
    uint32 GetCycleCount      (int node);
    void   InitialisePcie     (callback_t cb_func, int node);
    void   ConfigurePcie      (int type, int value, int node);
    void   PcieRand           (int node);
    void   PcieSeed           (int seed, int node);
</pre>

<h4>Internal Memory Access Function</h4>
<pre style="font-size:8pt">
    void   WriteRamByteBlock (uint64 addr, const PktData_t *data, int fbe, int lbe, int byte_length, uint32 node);
    int    ReadRamByteBlock  (uint64 addr, PktData_t *data, int byte_length, uint32 node);
    void   WriteRamByte      (uint64 addr, uint32 data, uint32 node);
    void   WriteRamWord      (uint64 addr, uint32 data, int little_endian, uint32 node);
    void   WriteRamDWord     (uint64 addr, uint64 data, int little_endian, uint32 node);
    uint32 ReadRamByte       (uint64 addr, uint32 node);
    uint32 ReadRamWord       (uint64 addr, int little_endian, uint32 node);
    uint64 ReadRamDWord      (uint64 addr, int little_endian, uint32 node);

    void   WriteConfigSpace  (const uint32 addr, const uint32 data, const uint32 node);
    uint32 ReadConfigSpace   (const uint32 addr, const uint32 node);

</pre>

<a name="IntArch"></a>
<h2>Further Internal Architecture</h2>
<p>
Some discussion of internal structure has already been made in the 
description of the API. In particular, <tt>SendPacket()</tt>, <tt>ExtractPhyInput()</tt>
and <tt>ProcessInput()</tt>, as the main Tx/Rx processing routines. 
Further detail of the rest of the internal code is now given below.
</p>

<a name="IntFunc"></a>
<h3>Other Internal Functions</h3>
<p>
Described above are the main functions which comprise the PCIe model. In 
addition to these, however, are several other support functions not mentioned
previously. These are listed now with a brief synopsis to aid navigation 
through the source code.
</p>

<table align=center width=95% style="font-size:10pt" align=center cellspacing=0 cellpadding=4 border=0>
 <tr><th>Function</th><th>Description</th></tr>
 <tr><td><tt style="font-size:8pt">CalcByteCount()</tt></td>        <td>Calculates a completion header byte count from a given length and byte enables</td></tr>
 <tr><td><tt style="font-size:8pt">CalcLoAddr()</tt></td>           <td>Calculates a completion headers low address field</td></tr>
 <tr><td><tt style="font-size:8pt">CalcBe()</tt></td>               <td>Calculates byte enables from a given address and length</td></tr>
 <tr><td><tt style="font-size:8pt">CheckCredits()</tt></td>         <td>Returns true of false on enough available credits for transmission of packet </td></tr>
 <tr><td><tt style="font-size:8pt">ProcessRxFlowControl()</tt></td> <td>Counts received packet credits, and sends out FC updates when required. Called from ProcessInput() for each received packet</td></tr>
 <tr><td><tt style="font-size:8pt">UpdateConsumedFC()</tt></td>     <td>Updates consumed header and data credit counts, emulating finite processing time of received packets. Called once a cycle from ExtractPhyInput().</td></tr>
 <tr><td><tt style="font-size:8pt">CalcDllpCrc()</tt></td>          <td>Calculates DLLP crc for given DLLP packet </td></tr>
 <tr><td><tt style="font-size:8pt">CalcEcrc()</tt></td>             <td>Calculates ECRC digest for given TLP packet</td></tr>
 <tr><td><tt style="font-size:8pt">CalcLcrc()</tt></td>             <td>Calculates LCRC for given TLP packet</td></tr>
 <tr><td><tt style="font-size:8pt">AckPkt()</tt></td>               <td>Updates state of received packet acknowledges</td></tr>
 <tr><td><tt style="font-size:8pt">NakPkt()</tt></td>               <td>Updates state of received packet not-acknowledges</td></tr>
 <tr><td><tt style="font-size:8pt">ProcessOS()</tt></td>            <td>Maintains state on physical set reception. Called from ExtractPhyInput() on reception of an OS/TS.</td></tr>
 <tr><td><tt style="font-size:8pt">InitPcieState()</tt></td>        <td>Initialises internal model state to defaults. Called from InitialisePcie()</td></tr>
 <tr><td><tt style="font-size:8pt">CalcNewRand()</tt></td>          <td>Platform independent random number function.</td></tr>
 <tr><td><tt style="font-size:8pt">CheckFree()</tt></td>            <td>stdlib free() function with pre-checking for NULL</td></tr>
 <tr><td><tt style="font-size:8pt">InitFc()</tt></td>               <td>Instigates transmission of FC initialisation packets</td></tr>
</table>

<a name="IntMem"></a>
<h3>Internal Memory Structure</h3>
<p>
The PCIe model (optionally) supports memory access requests for the full 64 bit address
space accessible by PCI Express transactions with an internal memory model. 
It does this with routines defined in <tt>mem.c</tt>, which initialise with no actual 
memory space allocated. As shown on the diagram, normally only <tt>ProcessInput()</tt> has access 
to the memory, and <tt>mem.c</tt> provides two functions for writes and 
reads&mdash;<tt>WriteRamByteBlock()</tt> and <tt>ReadRamByteBlock()</tt>. The user code has
access to these functions, as well as some byte and word access hybrid versions.
</p><p>
The full 64 bit space capability relies on the fact that a simulation run cannot
possibly write to all 2^64 locations. Instead, the space is divided into 4K byte
chunks which get dynamically allocated as required, and are accessed via
references in a series of tables which further divided the address space. The
starting point for a lookup is the <tt>PrimaryTable</tt>. This table has 4K entries, but
maps all the top 40 bits of the address space into this space, using a simple
hash, XORing the bits in a certain way and then bit reversing the 12 bit result.
The <tt>PrimaryTable</tt> entry structure (<tt>PrimaryTable_t</tt>) has a valid field and
an address for storing the top 40 bits of the address that hits on the location.
If another address upper 40 bits hashes to the same location, then the index
pointing to the table entry is simply incremented until an empty entry is
found, or we searched the whole table (an error condition).
</p>

<center>

<img width=650 style="border:5px solid #d0e0e0; border-style:ridge;box-shadow: 10px 10px 10px #e0e0e0;" src="images/TableDiag.png">
</center>
<br>
<p>
The primary table entry also contains a pointer to a pointer, which references
a secondary table, dynamically allocated when first written to. The secondary
tables sub-divide the address space of the lower 24 bits of the address into
the 4K byte blocks required. The upper 12 bits of the lower address index into
the secondary table, whose entry points to a 4K byte block of memory, dynamically
allocated on first access. Because PCI Express does not allow crossing
of 4K boundaries within a transaction, there is never any need to access more
than one memory block at a time for a given transaction.
</p><p>
Reading from a location simply involves traversing the table. The top 40 bits
of the read address are hashed, and index into the primary table. The Primary
table entry address is compared with the read address 40 bits and, if different,
the index is incremented until a match, an invalid address is encountered or
the whole table is searched. The last two cases are an error condition. The
secondary table is then accessed with the next 12 bits and (if pointing to
a valid byte block), the lower 12 bits used to retrieved the data. At any
point in the traverse, an unallocated table entry of byte block is considered
a fatal error&mdash;it is not legal to access locations that have not be written.
</p>

<a name="cfgspc"></a>
<h4>Internal Endpoint Configuration Space</h4>
<p>
If the pcieVHost is configured as an endpoint, it reserves a page, separate 
from the other internal memory, that can be accessed via the configuration
read and write command over the PCIe link. In addition there are a couple
of access functions, <tt>WriteConfigSpace()</tt> and <tt>ReadConfigSpace()</tt>, that allow
local word (32 bit) access to this memory from the user programs. When not
an enpoint, or if internal memory accesses is disabled, via <a href="#Config>user configuration</a>,
the pcieVHost will pass these packets up to the user input callback (if one 
registered), and respond to configuration reads as an unsupported request.
</p>

<a name="pciedisplink"></a>
<h2>PCIe Monitor (PcieDispLink)</h2>
<p>
The PcieDispLink module is a verilog behavoural test component, that can be attached to the
up and down links of the PCIe host model, and any connected test unit's PCIe link.
The main purpose of the PCIe DispLink function is to provide logging data for
activity on the PCIe link. It is a separate verilog component, rather than integrated
into pcieVHost so that it can be used with other modules, such as some verification IP (VIP)
and/or an implementation being tested or exercised.
It is controlled by bits in the <tt>ContDisp.hex</tt>
display control file, located in <tt>verilog/test/hex</tt>, (discussed shortly). A secondary function is to check
the link for PCIe protocol violations, and report them to the log file. In this
respect it is not an exhaustive protocol checker, with many compilance checklist
features unsupported, and no coverage measurements. The <tt>ContDisp.hex</tt> file consists
of a list of two numbers, the first being a hex number containing the control bits, 
followed by a decimal cycle number. 
</p>
<p>
The display output to the log from PcieDispLink is controlled by 4 bits. PCIe has three
'virtual' layers; transaction, data link and physical. Three bits in the <tt>ContDisp.hex</tt>
vector enable display of the associated layer. These bits are defined as <tt>`DispTL</tt>,
<tt>`DispDL</tt> and <tt>`DispPL</tt> respectively, defined in the file <tt>verilog/headers/pcidispheader.v</tt>.
A fourth separate bit, `DispRawSym enables a display of all raw decoded symbol values.
In addition to the four individual display controls,
a <tt>`DispAll</tt> bit forces all to be displayed, including the extra raw lane data.
Some control of the simulation is given by two more bits, <tt>`DispFinish</tt>, <tt>`DispStop</tt>, which
activate <tt>$finish</tt> and <tt>$stop</tt> verilog system task calls. An example 
<tt>ContDisp.hex</tt> file, which enables the TL, DL and PL layers at time zero, and calls
<tt>$finish</tt> at cycle 9999999999, is shown below:
</p>
<pre style="font-size:8pt">
  //                     +8              +4              +2              +1
  // ,-->  7 - 4:    DispRawSym         DispPL         DispDL          DispTL
  // |,->  3 - 0:    unused             DispStop       DispFinish      DispAll
  // || ,-> Time (clock cycles, decimal)
  // || |                          
     70 000000000000
     02 009999999999
</pre>
<p>
Below are shown three sample sections of output with only the transaction layer
on, then data link layer added and finally the physical layer.
</p>

<a name="tl"></a>
<h3>Transaction Layer Only</h3>
<pre style="font-size:8pt">
  PCIEU1: TL MEM read req Addr=130476dc48383000 (64) RID=0000 TAG=00 FBE=1111 LBE=1111 Len=002
  PCIEU1: Traffic Class=0, TLP Digest
  PCIEU1: TL Good ECRC (fc9cae82)
  PCIED0: TL Completion with Data Successful CID=0008 BCM=0 Byte Count=008 RID=0000 TAG=00 Lower Addr=00
  PCIED0: Traffic Class=0, TLP Digest, Payload Length=0x00000002 DW
  PCIED0: fedcba89 76543210 
  PCIED0: TL Good ECRC (af090c09)
</pre>
<a name="tldl"></a>
<h3>Transaction and Data Link Layer</h3>
<pre style="font-size:8pt">
  PCIEU1: DL Sequence number=11
  PCIEU1: ...TL MEM read req Addr=130476dc48383000 (64) RID=0000 TAG=00 FBE=1111 LBE=1111 Len=002
  PCIEU1: ...Traffic Class=0, TLP Digest
  PCIEU1: ...TL Good ECRC (fc9cae82)
  PCIEU1: DL Good LCRC (c235be07)
  PCIEU1: DL Ack seq 11
  PCIEU1: DL Good DLLP CRC (5893)
  PCIED0: DL Sequence number=0
  PCIED0: ...TL Completion with Data Successful CID=0008 BCM=0 Byte Count=008 RID=0000 TAG=00 Lower Addr=00
  PCIED0: ...Traffic Class=0, TLP Digest, Payload Length=0x00000002 DW
  PCIED0: ...fedcba89 76543210 
  PCIED0: ...TL Good ECRC (af090c09)
  PCIED0: DL Good LCRC (eeed0266)
  PCIED0: DL Ack seq 0
  PCIED0: DL Good DLLP CRC (b362)
</pre>
<a name="tldlpl"></a>
<h3>Transaction, Data Link and Physical Layer</h3>
<pre style="font-size:8pt">
  PCIEU1: {STP 
  PCIEU1: 00 0b 20 00 80 02 00 00 00 ff 13 04 76 dc 48 38 30 00 fc 9c ae 82 
  PCIEU1: c2 35 be 07 
  PCIEU1: END}
  PCIEU1: ...DL Sequence number=11
  PCIEU1: ......TL MEM read req Addr=130476dc48383000 (64) RID=0000 TAG=00 FBE=1111 LBE=1111 Len=002
  PCIEU1: ......Traffic Class=0, TLP Digest
  PCIEU1: ......TL Good ECRC (fc9cae82)
  PCIEU1: ...DL Good LCRC (c235be07)
  PCIED0: {SDP 
  PCIED0: 00 00 00 0b 58 93 
  PCIED0: END}
  PCIEU1: ...DL Ack seq 11
  PCIEU1: ...DL Good DLLP CRC (5893)
  PCIED0: {STP 
  PCIED0: 00 00 4a 00 80 02 00 08 00 08 00 00 00 00 fe dc ba 89 76 54 32 10 
  PCIED0: af 09 0c 09 ee ed 02 66 
  PCIED0: END}
  PCIED0: ...DL Sequence number=0
  PCIED0: ......TL Completion with Data Successful CID=0008 BCM=0 Byte Count=008 RID=0000 TAG=00 Lower Addr=00
  PCIED0: ......Traffic Class=0, TLP Digest, Payload Length=0x00000002 DW
  PCIED0: ......fedcba89 76543210 
  PCIED0: ......TL Good ECRC (af090c09)
  PCIED0: ...DL Good LCRC (eeed0266)
  PCIEU1: {SDP 
  PCIEU1: 00 00 00 00 b3 62 
  PCIEU1: END}
  PCIED0: ...DL Ack seq 0
  PCIED0: ...DL Good DLLP CRC (b362)
</pre>

<p>
Two key points to note on the output; firstly, as each 'lower' layer is switched on,
the layers 'above' are indented to make them easier to scan. Secondly, the up and down
links are marked as PCIEU and PCIED respectively, along with the node number, allowing data to be extracted for
one direction if desired. However, at the data link layer, acknowledge packets (Ack and
Nak DLLPs) are associated with the <em>opposite</em> link from which they are issued,
so they can be associated with the transaction which they refer to (i.e. their sequence
number match). This is <em>not</em> true of completion data returning after a request,
as this level effectively sits above the link. 
</p>
<a name="protocol"></a>
<h3>Protocol Checking</h3>
<p>
As mentioned above, the PcieDispLink checking of PCIe protocols is not comprehensive,
and should not be used as sign off criteria, where a third party 'VIP' module should be used. 
However, it does check many compliance checklist specifications, and a summary is given below.
</p>
<ul>
<li>Valid 10b encodings
<li>Correct running disparity
<li>Correctly formatted packets
<li>Reserved fields are 0
<li>CRCs checked
<li>Crossing of 4K boundaries
<li>Reuse of tags
<li>Valid completion cross referencing
</ul>
<p>
In general terms, what is not covered is compliance with limitations set in the configuration
space, ordering rules, and other 'higher level' considerations.
</p>

<a name="test"></a>
<h2>Test Environment</h2>

<p>
Included in the package is an example test environment that connects two pcieVHost components back to back,
and hooks up two PcieDispLink monitors to the up and down links. The configuration is shown in the 
diagram below.
</p>

<center>
<img width=800 src="images/pcieTest.png">
</center>

<p>
This example environment is simply meant to illustrate the usage of the various components,
and how they are connected up. Two simple test programs <tt>VUserMain0()</tt> and <tt>VUserMain1()</tt> are written
to exercise the PCIe link, with the VUserMain1 code being fairly passive, and various transaction
types output from <tt>VUserMain0()</tt>. The whole environment is for a 16 lane interaface, and user wide lanes
(i.e. unserialised 10 bit codes), for speed of simulation. 
</p>
<p>
The link displays have additional ports, apart from the link inputs and <tt>ContDisp</tt> control. The 
node number is 0 and 1, where this matches the node number of the pcieVHost's <tt>LinkOut</tt>&mdash;one for each
host instantiated. The <tt>FwdName</tt> and <tt>BckName</tt> is a string&mdash;in this case <tt>"D"</tt> and <tt>"U"</tt>, where each
PcieDispLink has the opposite from its counterpart, with node 0 being the 'root', and its <tt>LinkOut</tt>
being the downlink. The three other ports, <tt>LinkWidth</tt>, <tt>DisableScramble</tt> and <tt>InvertTxPolarity</tt> are 
set to constants, as shown. Obviously, in a proper test environment, these can be connected to 
state that reflects the expected settings if, for a given test say, scrambling were turned off, 
or the outputs inverted.
</p>

<a name="download">Download</a>
<p>
The <tt>pcieVHost</tt> is available for download on <a href="https://github.com/wyvernSemi/pcievhost">github</a>.
It uses the Virtual processing element <a href="http://www.anita-simulators.org.uk/wyvernsemi/VProc/index.html">VProc</a>,
which can also be downloaded from <a href="https://github.com/wyvernSemi/vproc">github</a>. 
These two components must be installed with their own top level directories (<tt>VProc</tt> and <tt>pcieVHost</tt>) 
in a common directory, in order to work 'out of the box'. If the VProc component is located elsewhere, then update
the <tt>VPROC_TOP</tt> variable in the two <tt>makefile</tt> files, located at <tt>pcieVHost/lib</tt> (for the C compilation)
and <tt>pcieVHost/verilog/test</tt> (for the top level test simulation) to the appropriate location, either
as an absolute path, or relative to the pcieVHost directories.
</p>

<a name="RelDoc"></a>
<h2>Related Documents</h2>

<ul>
<li><a href="http://www.anita-simulators.org.uk/wyvernsemi/VProc/index.html">Virtual Processor</a>
<li><a href="http://read.pudn.com/downloads161/doc/729268/PCI_Express_Base_11.pdf">PCI Express Base Specification 1.1</a>
</ul>

<hr>
<address>
Copyright &copy; 2016 Simon Southwell<br>
<a href="mailto:simon&#64anita-simulators.org.uk">simon&#64anita-simulators.org.uk</A>
</address>
<br>

<!------------------>
</HTML>
